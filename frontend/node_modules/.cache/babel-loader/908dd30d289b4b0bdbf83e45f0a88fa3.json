{"ast":null,"code":"import { isObject } from './is.js';\nexport const validateAndMerge = (...sources) => {\n  for (const source of sources) {\n    if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n      throw new TypeError('The `options` argument must be an object');\n    }\n  }\n\n  return deepMerge({}, ...sources);\n};\nexport const mergeHeaders = (source1 = {}, source2 = {}) => {\n  const result = new globalThis.Headers(source1);\n  const isHeadersInstance = source2 instanceof globalThis.Headers;\n  const source = new globalThis.Headers(source2);\n\n  for (const [key, value] of source.entries()) {\n    if (isHeadersInstance && value === 'undefined' || value === undefined) {\n      result.delete(key);\n    } else {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n};\nexport const deepMerge = (...sources) => {\n  let returnValue = {};\n  let headers = {};\n\n  for (const source of sources) {\n    if (Array.isArray(source)) {\n      if (!Array.isArray(returnValue)) {\n        returnValue = [];\n      }\n\n      returnValue = [...returnValue, ...source];\n    } else if (isObject(source)) {\n      for (let [key, value] of Object.entries(source)) {\n        if (isObject(value) && key in returnValue) {\n          value = deepMerge(returnValue[key], value);\n        }\n\n        returnValue = { ...returnValue,\n          [key]: value\n        };\n      }\n\n      if (isObject(source.headers)) {\n        headers = mergeHeaders(headers, source.headers);\n        returnValue.headers = headers;\n      }\n    }\n  }\n\n  return returnValue;\n};","map":{"version":3,"sources":["../../source/utils/merge.ts"],"names":[],"mappings":"AACA,SAAQ,QAAR,QAAuB,SAAvB;AAEA,OAAO,MAAM,gBAAgB,GAAG,CAAC,GAAG,OAAJ,KAAsE;AACrG,OAAK,MAAM,MAAX,IAAqB,OAArB,EAA8B;AAC7B,QAAI,CAAC,CAAC,QAAQ,CAAC,MAAD,CAAT,IAAqB,KAAK,CAAC,OAAN,CAAc,MAAd,CAAtB,KAAgD,OAAO,MAAP,KAAkB,WAAtE,EAAmF;AAClF,YAAM,IAAI,SAAJ,CAAc,0CAAd,CAAN;AACA;AACD;;AAED,SAAO,SAAS,CAAC,EAAD,EAAK,GAAG,OAAR,CAAhB;AACA,CARM;AAUP,OAAO,MAAM,YAAY,GAAG,CAAC,OAAA,GAAyB,EAA1B,EAA8B,OAAA,GAAyB,EAAvD,KAA6D;AACxF,QAAM,MAAM,GAAG,IAAI,UAAU,CAAC,OAAf,CAAuB,OAAvB,CAAf;AACA,QAAM,iBAAiB,GAAG,OAAO,YAAY,UAAU,CAAC,OAAxD;AACA,QAAM,MAAM,GAAG,IAAI,UAAU,CAAC,OAAf,CAAuB,OAAvB,CAAf;;AAEA,OAAK,MAAM,CAAC,GAAD,EAAM,KAAN,CAAX,IAA2B,MAAM,CAAC,OAAP,EAA3B,EAA6C;AAC5C,QAAK,iBAAiB,IAAI,KAAK,KAAK,WAAhC,IAAgD,KAAK,KAAK,SAA9D,EAAyE;AACxE,MAAA,MAAM,CAAC,MAAP,CAAc,GAAd;AACA,KAFD,MAEO;AACN,MAAA,MAAM,CAAC,GAAP,CAAW,GAAX,EAAgB,KAAhB;AACA;AACD;;AAED,SAAO,MAAP;AACA,CAdM;AAgBP,OAAO,MAAM,SAAS,GAAG,CAAI,GAAG,OAAP,KAAoD;AAC5E,MAAI,WAAW,GAAQ,EAAvB;AACA,MAAI,OAAO,GAAG,EAAd;;AAEA,OAAK,MAAM,MAAX,IAAqB,OAArB,EAA8B;AAC7B,QAAI,KAAK,CAAC,OAAN,CAAc,MAAd,CAAJ,EAA2B;AAC1B,UAAI,CAAC,KAAK,CAAC,OAAN,CAAc,WAAd,CAAL,EAAiC;AAChC,QAAA,WAAW,GAAG,EAAd;AACA;;AAED,MAAA,WAAW,GAAG,CAAC,GAAG,WAAJ,EAAiB,GAAG,MAApB,CAAd;AACA,KAND,MAMO,IAAI,QAAQ,CAAC,MAAD,CAAZ,EAAsB;AAC5B,WAAK,IAAI,CAAC,GAAD,EAAM,KAAN,CAAT,IAAyB,MAAM,CAAC,OAAP,CAAe,MAAf,CAAzB,EAAiD;AAChD,YAAI,QAAQ,CAAC,KAAD,CAAR,IAAmB,GAAG,IAAI,WAA9B,EAA2C;AAC1C,UAAA,KAAK,GAAG,SAAS,CAAC,WAAW,CAAC,GAAD,CAAZ,EAAmB,KAAnB,CAAjB;AACA;;AAED,QAAA,WAAW,GAAG,EAAC,GAAG,WAAJ;AAAiB,WAAC,GAAD,GAAO;AAAxB,SAAd;AACA;;AAED,UAAI,QAAQ,CAAE,MAAc,CAAC,OAAjB,CAAZ,EAAuC;AACtC,QAAA,OAAO,GAAG,YAAY,CAAC,OAAD,EAAW,MAAc,CAAC,OAA1B,CAAtB;AACA,QAAA,WAAW,CAAC,OAAZ,GAAsB,OAAtB;AACA;AACD;AACD;;AAED,SAAO,WAAP;AACA,CA5BM","sourceRoot":"","sourcesContent":["import { isObject } from './is.js';\nexport const validateAndMerge = (...sources) => {\n    for (const source of sources) {\n        if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n            throw new TypeError('The `options` argument must be an object');\n        }\n    }\n    return deepMerge({}, ...sources);\n};\nexport const mergeHeaders = (source1 = {}, source2 = {}) => {\n    const result = new globalThis.Headers(source1);\n    const isHeadersInstance = source2 instanceof globalThis.Headers;\n    const source = new globalThis.Headers(source2);\n    for (const [key, value] of source.entries()) {\n        if ((isHeadersInstance && value === 'undefined') || value === undefined) {\n            result.delete(key);\n        }\n        else {\n            result.set(key, value);\n        }\n    }\n    return result;\n};\nexport const deepMerge = (...sources) => {\n    let returnValue = {};\n    let headers = {};\n    for (const source of sources) {\n        if (Array.isArray(source)) {\n            if (!Array.isArray(returnValue)) {\n                returnValue = [];\n            }\n            returnValue = [...returnValue, ...source];\n        }\n        else if (isObject(source)) {\n            for (let [key, value] of Object.entries(source)) {\n                if (isObject(value) && key in returnValue) {\n                    value = deepMerge(returnValue[key], value);\n                }\n                returnValue = { ...returnValue, [key]: value };\n            }\n            if (isObject(source.headers)) {\n                headers = mergeHeaders(headers, source.headers);\n                returnValue.headers = headers;\n            }\n        }\n    }\n    return returnValue;\n};\n//# sourceMappingURL=merge.js.map"]},"metadata":{},"sourceType":"module"}